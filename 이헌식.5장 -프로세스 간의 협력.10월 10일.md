# 1.프로세스의 개념

프로세스란 실행 중인 프로그램을 뜻합니다.
디스크에 저장되어있는 실행 프로그램이 메모리에 올라가서 실행 되는 순간 생명력을 가지는
프로세스가 되고, 프로세스는 자신의 코드를 수행하기도하고 입출력 작업을 수행후 사라지게 됩니다.

중요함
프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미하는것을 Context(프로세스문맥)라 합니다. 쉽게 말하자면 정확한 재현을 위해 필요한 정보 즉 프로세스의 주소공간(코드,데이터,스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지, 시스템 콜을 통해 커널에서 수행한 일의 상태, 커널이 관리하고있는 각종 정보를 포함하는 것을 프로세스 문맥이라 합니다.

- 하드웨어 문맥
 CPU의 수행상태를 나타내는 것이고 보통(프로그램의 카운터 값,각종 레지스트에 저장되어 있는 값)
- 프로세스의 주소 공간
 코드,데이터,스택으로 구성된 자기만의 독자적인 *주소 공간*을 가지고있습니다.
 (주소 공간은 프로세스의 문맥을 결정하는 중요한 요소중 하나)
- 커널상의 문맥
운영체제가 프로세스를 관리하기 위한 자료구조를 유지한다.
(PCB,커널스택)이 이에 해당하며 프로세스의 문맥을 구성하는 중요한 요소중 하나다)


>PCB란 3장에서 배웠지만 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영 체제 커널의 자료 구조를 뜻하며 쉽게 말하면 운영체제가 프로세스를 저장하기 위해 정보를 저장해 놓은 곳을 뜻합니다.
프로세스 상태 정보를 저장하는 구조체라고 볼수있습니다.  
커널스택 이란 사용자 모드에서 커널모드로 떨어지게 될 때 커널모드 스택에 현재 사용자 cpu 레지스터등을 보관했다가, 다시 그 프로세스를 실행할 때가 되면 이것을 복원해주는 것.


# 2.프로세스의 상태

 프로세스를 3가지 상태로 구분할수 있는데 아래와 같이 
 
- 실행(runnig)
  프로세스가 CPU를 보유하고,기계어 명령을 실행하고 있는 상태.
- 준비(ready)
  프로세스가 CPU를 할당 받지 못한 상태.
- 봉쇄 (blocked,wait,sleep)
  CPU를 할당 받더라도 당장 명령을 실행할수 없는상태.
  (I/O 작업이 진행중인경우)
컴퓨터의 자원을 효율적으로 관리하기 위해서 위의 3가지 상태로 나눕니다.
이 밖에 new, terminated 상태도 있습니다. new는 자료구조는 생성 되었지만 메모리 획득을
승인받지못한 상태고, terminated는 프로세스가 종료되었지 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한상태를 말한다.

하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU제어권이 이양되는 과정들을 
Context switch(문맥교환)라 합니다. 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정이고,쉽게 말하면 타이머 인터럽트,입출력 요청등으로 봉쇄 상태로 바뀌는 경우 Context switch 과정이 이루어진다 라고 말할수 있고,
봉쇄 상태로 봐뀌어서 Ready 상태에 있는 프로세스들 중에서 cpu를 할당받을 프로세스를 선택해 실제로 cpu 제어권을 넘겨받는 과정을 dispatch(디스패치) 라 합니다. 

 
# 3.프로세스 제어블록

운영체제가 시스템내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널내의 자료구조가
프로세스 제어블록 PCB(Process Control Block) 라 합니다.

- 프로세스의 상태
	CPU를 할당해도 되는지 여부를 결정하기 위해 필요한 요소.
- 프로그램 카운터의 값
	다음에 수행할 명령의 위치를 가르키는 요소.
- CPU 레지스터의 값
 	CPU연산을 위해 현 시점 레지스터에 어떤값을 저장하고있는지 나타내는 요소.
- CPU 스케줄링 정보
 	각각 프로세스의 CPU 스케줄링을 위해 필요한 정보 요소.
- 메모리 관리 정보
	각각 프로세스의 메모리 관리를 위해 필요한 정보 요소.
- 자원 사용 정보
	사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도.
- 입출력 상태 정보
	오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보.

PCB는 위와 같이 7개의 구성되어 있습니다.



# 4.문맥 교환

중요해서 그런지 아까 말했었는데 또나오네요!
다시한번 말씀드리자면 Context switch(문맥교환)은
하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU제어권이 이양되는 과정을 Context switch(문맥교환)라 합니다. 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정이고,쉽게 말하면 타이머 인터럽트,입출력 요청등으로 봉쇄 상태로 바뀌는 경우 Context switch 과정이 이루어진다 라고 말할수 있습니다.

문맥교환에 소요되는 시간은 시스템 입장에서는 유용한 작업이 아니기 때문에 오버헤드라고도 볼 수 있습니다. 
> overhead(오버헤드)
오버 헤드는 특정 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원을 말한다. 예를들어,  10초 걸리는 기능이 간접적인 원인으로 20초걸린다면 오버헤드는 10초가 되는것이다. 

타이머 CPU에 할당시간을 적절하게 해야합니다. 너무 적게되면 오버헤드가 커지고 너무 크게되면 시분할 시스템의 의미가 퇴색되기 떄문입니다.


# 5.프로세스를 스케줄링 하기 위한 큐



운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비큐를 두고 

실행될 프로세스가 여러개 있으면 하나만 실행되고 나머지는 CPU가 자유로워 질때까지 대기하는 것으로 선입선출 방식을 따릅니다. 큐의 종류에는 작업 큐, 준비 큐,장치 큐가있고
Job Queue 는 메모리 할당을 대기 중인 프로세스들로 구성되고, Ready Queue는 CPU 할당을 대기 중인 프로세스들로 구성되며, Device Queue는 입출력 장치 할당을 대기 중인 프로세스들로 구성됩니다.
좀 더 자세하게 보자면
- job queue : 상태에 상관없이 모든 프로세스를 저장하고, 관리하기 위한 자료구조이며, 따라서, 반드시 메모리가 할당되어 있는 프로세스만 있지 않고, 말그대로 모든 프로세스가 담겨있습니다.

- ready queue : 프로세스 상태에서 배웠던 ready 상태(CPU의 할당을 기다리는 상태로, 할당만되면 바로 실행할 수 있는 대기상태)에 해당하는 프로세스들을 관리하는 큐로 이러한 ready queue에 있는 프로세스들에게 CPU를 어떻게 할당할지(공평하게?)를 결정하는 스케줄링 알고리즘이 있는데, 이 때, job queue와 달리 레디큐에 있는 모든 프로세스에는 메모리가 할당된 상태입니다.

- device Queue : 각각의 장치마다 사용되기를 기다리며 줄 서 있는 프로세스들을 관리합니다. 장치 큐에 속한 프로세스는 봉쇄 상태(blocked)가 된다. 봉쇄 상태에 있다가 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 준비큐로 이동한다고 합니다.

![](https://velog.velcdn.com/images/hunsik0302/post/f8c070db-b764-4376-8608-b297f49c27ca/image.PNG)

프로세스가 시스템에 들어가면 이들은 잡 큐에 넣어지고, 잡큐는 시스템에서 모든 프로세스들이 존재하는 곳입니다. 메인메모리에 거주하는 프로세스들은 레디 큐라고 불리우는 리스트에서 실행되기를 기다리고 대기를 합니다. 큐는 보통 Linked list로 저장되며 레디 헤더는 포이터를 포함하고있으며, 이 포인터는 리스트에서 PCB의 처음과 끝을 가르 킵니다.
각 PCB는 포인터 필드를 포함하고 있는데, 이는 레디 큐에 있는 다음 PCB를 가르킵니다.





# 6. 스케줄러

어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭 하는것을 스케줄러라 한다.

- Long Term Scheduler (장기 스케줄러)
프로그램을 시작할때 프로세스를 큐에 줄지말지 결정하고,메모리에 올라가있는 프로세스의 수를 제어하는 놈입니다.(메모리에 프로그램을 동시에 몇개 올려놓을지 제어하는놈)

메모리에 너무 많은 프로그램과 너무 적은 프로그램이 들어가있으면 전체적인 컴퓨터 성능이 안좋아 지기때문에 degree of multiprograming을 통해 제어합니다.

보통 우리가 사용하는 프로그램에선 장기스케줄러는 없다고합니다.


Short Term Scheduler (CPU 스케줄러 라고도 불리고 한국말로는 단기 스케줄러)

어떤 프로세스를 다음번에 러닝 시킬지 결정을 하고, 프로세스에 CPU를 할당할 것인지를 결정합니다.
밀리세컨드 단위로 엄청 자주 수행되기 때문에 매우 빨라야합니다. 


Medium Term Scheduler (중기 스케줄러) & 스와퍼 
메모리에 많은 프로그램이 들어가있으면 스와퍼가 일부 프로그램을 골라서 메모리에서 내보낸다.
degree of multiprograming을 제어 합니다.

스와퍼때문에 서스펜드 상태가 추가됬다.

> 서스펜드란?
cpu뿐만아니라 외부에서 이 프로세스를 강제로 정지해논 상태를 말합니다. 하던일을 멈추고 정지된 상태입니다. 메모리에 너무많은 프로세스 올라와있을때 프로세스 통쨰로 디스크에 (스왑 아웃)내려 놓습니다.

현대의 대부분 시분할 운영체제를 사용하고  그 시분할 운영체제 에서는 중기 스케줄러 즉 스와퍼를 두는 경우가 많다고 합니다.



# 7.프로세스의 생성

프로세스 생성은 부모 프로세스가 연산을 통해 자식 프로세스를 만들어냅니다. 생성된 자식 프로세스 또한 새로운 자식 프로세스를 만들 수 있으며 이를 구별하기 위해 모든 프로세스는 각자 고유의 PID를 가지게 됩니다. 

생성된 자식 프로세스는 각자 고유의 PID, 메모리, CPU 등 새 PCB가 할당되며 고유의 자원을 획득하게 됩니다. 이로 인하여 부모 프로세스의 자원 접근에 제한이 생기며 특수한 방법을 통해 공유할 수 있게 됩니다.


프로세스를 생성한 후 부모 프로세스는 다음과 같이 2가지 행동을 할 수 있습니다.

부모 프로세스와 동일한 새로운 프로세스 : 이 경우 부모 프로세스의 프로그램, 데이터가 완전 복사됩니다.
새로운 프로그램 실행 : 새로운 프로그램을 메모리에 load 하고 이를 실행하게 됩니다.
 
프로세스의 생성 절차에 대해 예를 들자면
fork(), exec(), wait() 함수 등이 있습니다.

* fork()

Linux/UNIX 환경에서 새로운 프로세스를 만드는 시스템 콜 함수입니다.

생성된 자식 프로세스는 부모 프로세스의 데이터와 프로그램이 완전 복사가 되어 똑같은 프로그램을 수행하는 프로세스가 됩니다. 이를 통해 부모, 자식 프로세스가 서로 간편하게 의사소통을 할 수 있습니다.
멀티 프로세싱을 통해 부모, 자식 프로세스는 함께 동작합니다.
fork() 함수는 부모 프로세스에서 자식의 PID를 반환하고, 자식 프로세스에서는 0을 반환하여 구분할 수 있도록 해 줍니다.


 

* exec()

Linux/UNIX 환경에서 프로세스를 새로운 프로그램을 실행하는 프로세스로 대체하는 시스템 콜 함수입니다.

fork()와 다르게 자식 자식 프로세스를 생성하는 것이 아닌 현재 프로세스의 프로그램 코드를 새로운 프로그램 코드로 바꿔줍니다. 이로 인하여 프로그램 코드, 메모리, 파일 등 프로세스 자원이 새로 바뀌게 됩니다.
exec() 함수는 현재 프로세스가 완전히 새로운 프로그램을 실행하는 프로세스로 대체되므로 반환 값이 없습니다.


보통 동작하는 방식은 fork()를 통해 자식 프로세스를 생성하고 자식 프로세스에서 exec()를 통해 새로운 프로그램을 돌리게 됩니다. 이때 부로 프로세스가 자식 프로세스가 끝나기를 기다려야 한다면 wait() 시스템 콜 함수를 이용하여 기다릴 수 있습니다.

 

* wait()

pid_t wait(int * statloc) 형태이며 자식 프로세스가 종료될 때까지 현재 프로세스의 동작을 멈추는 시스템 콜 함수입니다.
자식 프로세스가 종료되면 자식 프로세스 종료 시그널(SIGSHLD)이 발생하여 waiting queue에 있는 부모 프로세스가 ready queue로 넘어가게 되어 다시 실행이 가능해집니다.
블럭 모드로 동작하기 대문에 비용이 비싸며 자식 프로세스 관리를 하지 않으면 무한정 대기, 혹은 함수가 OS에 의해 강제 종료당할 수 있습니다.
종료된 자식 프로세스의 PID를 반환하며 인자로 받은 statloc에 프로세스의 종료 상태를 알 수 있는 번호가 입력됩니다.



# 8. 프로세스 간의 협력


 원칙적으로 프로세스는 매우 독립적입니다. 자식이 하나 생성되더라도 부모가 자식 프로세스를 먹여 살리는 것이 아니라 일단 생성만 되면 나머지 일은 자식 프로세스가 알아서 실행합니다. 그러나 경우에 따라서는 프로세스가 협력을 해야만 효율적으로 실행되는 경우도 있을 것 입니다. 따라서 프로세스 간 협력 메커니즘이 존재하는데, 그것을 IPC(Interprocess Communication)이라 합니다. IPC에는 크게 두 가지 방법이 있습니다. 첫 번째는 message passing, 두 번째는 shared memory 입니다.


* Message passing 
 먼저 message passing은 프로세스 A가 프로세스 B와 서로 메시지를 주고받으며 실행되는 것입니다 그러나 프로세스는 원래 서로 독립적이기 때문에 자기 메모리 주소 공간만 볼 수 있으며 어떤 사용자 프로세스가 다른 사용자 프로세스에게 직접 메시지를 전달하는 방법은 원칙적으로는 존재하지 않습니다. 따라서 커널을 통해 메시지를 전달해야하고, 프로세스 사이에 공유되는 변수를 사용하는 것도 아니기 때문에 메시지를 전달하는 것인데 이 마저도 커널을 통해야 한다는 것입니다. 이 message passing은 전달받을 프로세스의 이름을 명시하느냐 않느냐에 따라서 또 두 가지 방법으로 나뉩니다.첫 번째는 Direct communication으로 이름을 명시하는 방법이며 두 번째는 Indirect communication으로 명시하지 않고 mailbox 혹은 port를 통해 간접적으로 전달하는 방법 입니다.
 

 


 

* Shared Memory
 
 Message passing 외에도 shared memory라는 방법을 통해서도 프로세스의 협력이 이루어질 수 있습니다. 원칙적으로 프로세스는 독자적이기 때문에 메모리 주소 공간에서 공유하는 부분은 없으나 특별한 경우(이 경우에서는 프로세스 협력)를 위해 shared memory를 두어 일부 영역은 물리적으로 매핑이 되도록 겹쳐 놓은 것입니다. 물론 프로세스 생성 시 기본적으로 주소 공간은 서로 겹치지 않기 때문에 커널에게 shared memory를 사용하겠다는 system call을 해야 합니다.

 ![](https://velog.velcdn.com/images/hunsik0302/post/ff074f96-9ea2-41aa-af2b-ff1b24d65267/image.png)


 

 
